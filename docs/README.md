# 语法/语义

## 模块

- 一个文件以 utf-8 编码 `.ez` 结尾的文件就是一个模块.
- 模块是编译的最小单位, 从上而下执行语句.
- 模块通过 `from import/export` 关键字导入/导出.
- 导入语句需要在文件最上方声明, 导入的变量和类型都不可以重复声明, 导入的变量只可读.
- 导出语句需要在模块最外层的作用域声明.
- 除了入口文件打包时生成的 `export` 外 其他文件编译时都生成一个 hash 用来做 namespace 隔离.

eg:

```
// foo.ez
export const ID = 1;
// b.ez
from "./foo" import { bar };
```

## 变量

- `const` 声明不可变变量, 不可修改, 赋值/被赋值非不可变变量时复制值, 声明时需要赋值.
- `static` 声明静态变量, 赋值/被赋值其他变量时复制值, 声明时需要赋值.
- `let` 声明可变变量, 可以先声明类型而不实际赋值, 赋值时不可以是不兼容的类型.
- 复杂类型的变量通过引用计数确定是否释放.
- 在同一个作用域中, 同名变量不可重复声明, 变量声明会提前到作用域最上方.
- 函数的参数是可变变量.
- 变量名需要遵循 `[a-z_][a-zA-Z0-9_]*`.
- 元组、字典、数组、结构体支持解构语法.

eg:

```
const a = { x: 1 };
const b = a; // a === b
static c = b; // c !== b
let d = c; // d !== c
let e = d; // e === d
e.x = 2; // d.x === 2
let f: U8?;
const { x } = e;
```

## 类型

- 类型分为简单类型与复杂类型, 简单类型在传递时遵循值传递, 复杂类型传递时遵循引用传递, 复杂类型的内存分配与释放通过自动引用计数来实现.
- 可通过 `type` 声明可擦除的类型别名, 通过 `struct/tuple` 声明编译后保留的别名.
- 可通过 `type!` 的方式来强制转换类型.
- 类型别名的命名遵循 `[A-Z][a-zA-Z0-9_]*`.
- 类型声明只能在模块最外层作用域, 同一个模块不能声明同名类型别名, 类型别名自动提升到最上方声明.
- 类型和类型别名可用作注解, 后面加 `?` 表示值可以为空.
- 可通过 `typeof` 关键字动态获取表达式的类型别名.

### 简单类型

简单类型包含 数字、布尔值、Null、Void、字符串.

- 数字:

  - 数字类型有 **I8, I16, I32, I64, U8, U16, U32, U64, D64** 几种.
  - 整型之间转换时自动满足目标类型的宽度, 不足的补 `0`, 溢出截断.
  - 浮点数转整形时去掉小数点, 整形转浮点数转为整形的浮点数表示.
  - `true` 转换为 `1`, `false`/`null` 转换为 `0`, 合法数字的字符串转换为 其余类型为 `NaN`.
  - 浮点数溢出时表示为 `infinity`/`-infinity`.
  - 数值可以使用默认的十进制、`0x` 开头的 16 进制、`0o`开头的 8 进制、`0b` 开头的 2 进制表示.

  eg:

  ```
  const i = 1; // 整数默认 I32类型
  const j = 1.0 // 浮点数默认 D64
  const k: U8 = 257; // 溢出自动截断 k == i
  ```

- 布尔类型:

  - 布尔值有 `true` 和 `false`.
  - 数字转换为布尔值时 `0` 是 `false` 其余为 `true`.
  - `null`/`void` 转换为布尔值都是 `false`.
  - 复杂类型转换为布尔值时都是 `true`.

  eg:

  ```
  const a: Bool = 1; // true
  ```

- 空:

  - 空分为 `void` 和 `null` 两种.
  - `void` 的类型是 `Void`, 代表不存在, 没有实际的值.
  - `null` 的类型是 `Null`, 是一个代表空的值.

  eg:

  ```
  const a = null;
  let b: u8?; // void
  ```

- 字符串:

  - 字符串是一种特殊的简单类型, 它以字符数组的形式存储, 但是以值的形式参与运算.
  - 字符串的类型是 `String` 通过 `""` 定义.
  - 字符串可以用 `{{表达式}}` 的方式来内连表达式.
  - 表达式转换字符串时转换为值的字符串表示.
  - 对于嵌套的循环引用节点, 较后出现的节点表示为 `<ref>`

  eg:

  ```
  struct A { a: U8, b: A? };
  let a = A(a = 1);
  a.b = a;
  "hello {{ a }}"; // hello A{ a: 1, b: <ref> }
  ```

### 复杂类型

复杂类型包括 函数、结构体、字典、元组、数组.

- 函数:

  - 函数拥有静态作用域定义时确定.
  - 函数支持不同的参数名、个数实现重载.
  - 函数的 `this` 参数可以声明为不同类型.
  - 函数重载时除 `this` 外, 同名参数类型必须一致.
  - 默认赋值的参数和可选参数可以不传递.
  - 不默认赋值的参数必须声明类型别名.
  - 函数传参时需要为具体的参数名赋值.
  - 函数签名匹配时优先匹配 `this` 类型, 然后匹配参数类型, 参数匹配个数越高匹配权重越大.
  - `this` 是一种不可变引用.
  - 函数传参时可以通过传 `?` 创造一个新函数.
  - 可以通过 `=>` 符号返回值.

  eg:

  ```
  const a = (
    (i: U8) => i,
    (i: U8, j: U8) {
      => i + j;
    }
  );
  const b = a(i = ?, j = 1);
  b(i = 1); // 2
  ```

- 结构体:

  - 结构体通过 `struct` 关键字声明.
  - 结构体声明时可以使用 `...` 扩展符, 扩展其他结构体类型.
  - 结构体自动对字段排序、对齐.
  - 结构体传参时可以通过传 `?` 创造一个函数.

  eg:

  ```
  struct A {
    a: U8;
    b = 2;
  };

  struct B {
    ...A,
    next: B?
  }

  const a = B(a = ?, b = 1)(a = 1);
  ```

- 元组:

  - 元组是一种特殊的结构体, 通过 `tuple[]` 声明值.
  - 元组自动对齐.
  - 元组可以使用 `...` 扩展符扩展其他元组.

  eg:

  ```
  const a = tuple[U8!1, 2];
  const b = tuple[...a, 3];
  ```

- 数组:

  - 数组通过 `[]` 声明值, 自动扩缩.
  - 数组可以使用 `...` 扩展符扩展其他元组/数组.

  eg:

  ```
  const a = [1, 2, 3];
  const b = [...a, 4];
  ```

- 字典:

  - 字典是一种 kv 结构的散列表, 通过 `{}` 声明值.
  - key 可以是 空 以外的任何类型, value 可以是任何类型.
  - key 是 ID 时可以直接写等同于字符串, 是表达式时使用 `[]` 包裹并求值后 hash
  - 字典可以通过 `...` 扩展符扩展其他字典/结构体;

  eg:

  ```
  let a = {
    abc = 123,
    [() => 1]: U8 = 1
  };
  ```

### 约束类型

- 类型约束主要用于类型检查, 编译时可擦除.
- 类型约束可以通过 `type` 定义.
- 类型约束以鸭子类型的方式验证是否满足约束.
- 可以通过 `{}` 声明字典约束, `[]` 声明元组约束, `类型[]` 声明数组, `(参数) => 类型` 声明函数签名, `|` 联合类型.
- 在字典类型声明时, 可以用 `[类型]` 来当作 key 以声明满足约束的 key.
- 可以使用 `...` 扩展符扩展其他类型.

eg:

```
type A = {
  hello: String;
};

type B = {
  world: String,
};

type C = {
  ...A,
  ...B,
  [String]: U8
};
```

## 语句

- 语句包括 导入语句、导出语句、声明语句、表达式语句、流程控制语句, 以 `;` 结尾.
- 语句从上而下依次执行.
- 声明语句、表达式语句、流程控制语句可以互相嵌套.

## 表达式

表达式遵循以下优先级:

| 运算符/表达式                                       | 含义                | 结合性 |
| --------------------------------------------------- | ------------------- | ------ |
| `123; "foo {{"bar"}}";`                             | 字面量表达式        | -      |
| `foo; foo.bar; foo["bar"]; foo?.bar; foo?.["bar"];` | get 操作            | -      |
| `(bar);`                                            | 分组                | -      |
| `foo(bar = 123); Foo(bar = 456);`                   | 函数调用/结构体创建 | -      |
| `-bar; !bar; ~bar; Foo!bar; typeof bar; @accessor`  | 一元运算            | -      |
| `* / %`                                             | 乘/除/摩            | 左     |
| `+ -`                                               | 加/减               | 左     |
| `<< >>`                                             | 左移/右移           | 左     |
| `& \| ^`                                            | 位与/位或/异或      | 左     |
| `== === != !== < > <= >=`                           | 关系运算            | 左     |
| `&& \|\|`                                           | 逻辑运算            | 左     |
| `foo -> bar + %%`                                   | 管道运算            | 左     |
| `=`                                                 | set 操作            | 右     |

### 字面量

字面量表达式直接描述一个值或求值的结果.

eg:

```
0x123;
"hello {{123}}";
[1,2,3];
```

### get/set 和 accessor

- set 前会自动向合法类型转换, 转换不了的抛出错误.
- get/set 操作触发之前如果有 accessor 就触发 accessor 的 getter/setter 并用 getter/setter 的返回值更新变量真实的值, 如果没有就执行默认 get/set 操作.
- get 操作可以使用 `?.` 的方式来作为可选链, 当目标为 空 时返回 `null`.
- 可以通过 `@函数` 的形式作为一个 accessor 值, getter 和 setter 必须保证返回值和目标类型一致.

eg:

```
const accessor = (initValue: U8) => (
  (this: U8?) => (this) ?? this :: initValue, // getter
  (this: U8?, value: U8?) => (this) ?? this + value :: initValue + value // setter
);
let a = {
  b = @accessor(initValue = U8!1)
};
a.b = 2; // 3
a.c?.d.e; // null
```

### 函数调用/结构体创建

- 函数调用/结构体创建可以通过传递 `?` 作为参数, 创建出一个新的函数.
- 当通过链式操作调用函数时把前面 get 的结果作为 `this` 传入.

```
type A = { b: I32, c: () => I32 };
const a = { b = 1, c = (this: A, i: I32, j: I32) => this.b + i + j };
const d = (this: A, i: I32) => this.b + i;
a.c(i = 1, j = ?)(j = 0) === d(this = a, i = 1); // true
```

### 一元运算

- `-` 符号位取反, 数字类型不变, 非数字转换为 I32 或 NaN.
- `~` 取反, 数字类型不变, 非数字转换为 I32 或 NaN.
- `!` 取非, 非 Bool 先转换为 Bool 类型.
- `类型!` 类型强转换, 不能成功转换的抛出错误.
- `typeof 表达式` 动态返回当时的类型名, 包括: I8、I16、I32、I64、U8、U16、U32、U64、D64、String、Bool、Null、Void、Dict、Tuple、Array、Function、结构体类型别名.
- `@函数` 把函数作为 accessor 值, 对对应的变量 get/set 操作时调用函数, 函数没有满足的签名时执行默认的 get/set 行为.

### 算术运算

- 非数字优先转化为 I32 参与运算, 转换不了的转换为 NaN.
- NaN 的运算结果都是 NaN.
- 运算时无符号向有符号转换, 宽度向较宽的一边转换, 整形向浮点数转换.
- 乘除转化为 D64.

eg:

```
const i: U8 = 1;
i + 1; // I32 类型的 2
i * 1; // D64 类型的 1.00
```

### 位运算

- 非数字优先转换为 I32 参与运算, 转换不了的转换为 NaN.
- 运算时无符号向有符号转换, 宽度向较宽的一边转换, D64 向 I64 转换.
- 有符号位移时使用算数位移.

eg:

```
const i: U8 = 2;
i << 1; // 4;
const j = i | -2; // I32 类型的 -2;
j >> 1; // I32 类型的 -1
```

### 关系运算

- 关系运算符返回值是 Bool 类型.
- `> >= < <=` 比较时有符号向无符号转换, 宽度向较宽的一边转换, 整形向浮点数转换, 非数字优先转换为 I32, 转换不了的转换为 NaN, NaN 的比较结果永远是 false.
- `!= ==` 用于比较值, 对于非数字如果类型不同则两侧不相等, 如果类型相同并且是引用则比较引用的值.
- `!== ===` 用于严格比较, 先比较类型, 类型完全相同且是引用比较引用否则比较值.

eg:

```
const a = [0, 1];
const b = [0, 1];
const c: U8 = 1;
const d = -1;
a == b; // true
a === b; // false
c < d; // true
```

### 逻辑运算

- 逻辑运算时非 Bool 值的转化为 Bool 值运算.
- null、0、0.00 转化为 false, 其他类型默认转化为 true.
- 逻辑运算符返回值是 Bool.

eg:

```
!true; // false;
0 && 1; // false;
```

### 管道运算符

- 管道运算符是 `->`.
- 管道运算符将上一个表达式的结果作为下一个表达式的参数, 由 `%%` 作为占位符.

eg:

```
const a = "123";
const hello = (str: String) => "hello {{ str }}";
a -> %% + 1 -> hello(str = %%); // hello 124
```

## 流程控制结构

### 匹配语句

- 匹配语句语法是 `match { (条件) ?? 表达式/代码块 };`.
- `match` 会从上到下逐个匹配 `条件A`, 当 `条件A` 是 `true` 时执行 `表达式/代码块`.
- `match` 可以使用 `break` 中断, 使用 `continue` 继续下一个匹配.

eg:

```
let i = 0;
match {
  (i == 0) ?? i = 100,
  (i > 0) ?? { continue; i = i - 1; },
  (i > 0) ?? { i = i + 1; break; },
  (true) ?? { i = i - 100; }
};
i; // 101
```

### 条件控制语句

- 条件控制语句的语法是 `(条件) ?? 表达式/代码块 :: 表达式/代码块`, 条件为 `true` 时执行前面的语句, 条件为 `false` 时执行后面的语句, 后面的语句可以不写.
- 条件控制语句的返回值是表达式时返回表达式的计算结果, 代码块返回 void.

eg:

```
let i = (i > 1) ?? 1 :: 0; // 0
(i < 1) ?? {
  i = 100
};
i; // 100
```

### 循环语句

- 循环语句的语法是 `loop 次数: 表达式/代码块`, 次数必须是大于 0 的整数, 不写次数代表无限循环.
- 可以使用 `break` 中断, `continue` 跳过后续代码.

eg:

```
let i = 0;
loop: {
  (i > 10) ?? break;
  i = i + 1;
};
i; // 11
loop 2: i = i + 1;
i; // 13
```

### 异常捕获

- 异常抛出可以使用 `throw` 关键字.
- 包裹在 `catch` 代码块中的代码抛出异常中断后不继续传递中断信号.
- 当触发了 `throw` 时 `catch` 代码块返回值是一个错误类型的值, 否则返回 void.

eg:

```
let i = 0;
const error = catch {
  i = 1;
  throw "123";
  i = 2;
};
i; // 1
declare printf = (msg: String) => Void;
(error) ?? {
  printf(msg = error.msg); // 打印 123
  i = 3;
};
i; // 3
```

## 标准库和链接

不出意外的话 EzLang 的标准库只会提供一些必须的能力.

- [ ] 操作**数组、元组、结构体、字典、字符串**的能力.
- [ ] 异常、捕获、迭代器、正则、时间、数学、SIMD、CBOR、常用的加解密等.
- [ ] IO、线程、进程相关能力

作为标准库的补充, EzLang 提供从 LLVM IR 层面链接的能力. 可以通过 `declare` 关键字来声明, 并在编译期间链接, 链接语句需要在模块最外层的作用域声明.

eg:

```
// a.ez
export declare pow = (a: I32, b: I32) => I32;

// main.ez
from "./a" import { pow };
pow(a = 1, b = 2);
```